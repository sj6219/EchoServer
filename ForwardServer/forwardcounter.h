//------------------------------------------------------------------
//                   !!! WARNING !!! 
//
// This file is auto generated by ctrpp.exe utility from performance
// counters manifest:
//
// echo.man
//
// It should be regenerated every time the code is built.
// Do not check it in.
//-------------------------------------------------------------------

#pragma once

#include <winperf.h>
#include <perflib.h>

#define EchoRunningThread (1)
#define EchoConnections (2)

EXTERN_C DECLSPEC_SELECTANY GUID EchoUserModeCountersGuid = { 0x9c1006fe, 0xc71f, 0x4b5b, 0xad, 0xf9, 0xd5, 0x5d, 0xb4, 0x7d, 0xd9, 0x2 };

EXTERN_C DECLSPEC_SELECTANY GUID EchoCounterSet1Guid = { 0xad216274, 0xab2a, 0x47dd, 0x8f, 0xf3, 0x45, 0x39, 0xef, 0x41, 0x27, 0xab };


EXTERN_C DECLSPEC_SELECTANY HANDLE EchoUserModeCounters = NULL;

EXTERN_C DECLSPEC_SELECTANY struct {
    PERF_COUNTERSET_INFO CounterSet;
    PERF_COUNTER_INFO Counter0;
    PERF_COUNTER_INFO Counter1;
} EchoCounterSet1Info = {
    { { 0xad216274, 0xab2a, 0x47dd, 0x8f, 0xf3, 0x45, 0x39, 0xef, 0x41, 0x27, 0xab }, { 0x9c1006fe, 0xc71f, 0x4b5b, 0xad, 0xf9, 0xd5, 0x5d, 0xb4, 0x7d, 0xd9, 0x2 }, 2, PERF_COUNTERSET_MULTI_INSTANCES },
    { 1, PERF_COUNTER_RAWCOUNT, 0, sizeof(ULONG), PERF_DETAIL_NOVICE, 1, 0 },
    { 2, PERF_COUNTER_RAWCOUNT, 0, sizeof(ULONG), PERF_DETAIL_NOVICE, 1, 0 },
};

EXTERN_C FORCEINLINE
VOID
CounterCleanup(
    VOID
    )
{
    if (EchoUserModeCounters != NULL) {
        PerfStopProvider(EchoUserModeCounters);
        EchoUserModeCounters = NULL;
    }
}

EXTERN_C FORCEINLINE
ULONG
CounterInitialize(
    __in_opt PERFLIBREQUEST NotificationCallback,
    __in_opt PERF_MEM_ALLOC MemoryAllocationFunction,
    __in_opt PERF_MEM_FREE MemoryFreeFunction,
    __inout_opt PVOID MemoryFunctionsContext
    )
{
    ULONG Status;
    PERF_PROVIDER_CONTEXT ProviderContext;

    ZeroMemory(&ProviderContext, sizeof(PERF_PROVIDER_CONTEXT));
    ProviderContext.ContextSize = sizeof(PERF_PROVIDER_CONTEXT);
    ProviderContext.ControlCallback = NotificationCallback;
    ProviderContext.MemAllocRoutine = MemoryAllocationFunction;
    ProviderContext.MemFreeRoutine = MemoryFreeFunction;
    ProviderContext.pMemContext = MemoryFunctionsContext;

    Status = PerfStartProviderEx(&EchoUserModeCountersGuid,
                                 &ProviderContext,
                                 &EchoUserModeCounters);
    if (Status != ERROR_SUCCESS) {
        EchoUserModeCounters = NULL;
        return Status;
    }

    Status = PerfSetCounterSetInfo(EchoUserModeCounters,
                                   &EchoCounterSet1Info.CounterSet,
                                   sizeof EchoCounterSet1Info);
    if (Status != ERROR_SUCCESS) {
        CounterCleanup();
        return Status;
    }
    return ERROR_SUCCESS;
}
